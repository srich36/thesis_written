%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% chapter3.tex                                 %
% Contains formatting and content of chapter 3 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Problem Implementation}
\section{Overview}
\noindent The finite thrust arc problem consists of 11 unknowns and requires two numerical integrations for each solution candidate within the
particle swarm. Additionally, it necessitates a high absolute and relative tolerance when integrated with variable step sized integrators. These
components serve to make this problem a suitable benchmark for the performance of different implementations of the particle swarm optimization algorithm. \newline

\noindent To maintain consistency between different implementation targets, the numerical integration algorithm, absolute and relative tolerance values,
and minimum step size constraints were held constant. All implementations employed a fifth order Runge-Kutta Dormand Prince variable step size integrator
throughout both thrust arcs. The tolerances were defined as

\begin{equation}
AbsTol = 10^{-9} \quad \text{and} \quad RelTol = 10^{-9} 
\label{eq:tolerances}
\end{equation}

\noindent And the minimum step sized as 

\begin{equation}
    h_{min} = 7.105427*10^{-15}
    \label{eq:min-step-size}
\end{equation}

\noindent Execution time was measured as wall-clock time (CPU time was not recorded) and was computed from swarm initialization 
to algorithm completion. File operations were not included within this measurement. \newline

\noindent The problem was benchmarked using the $\beta = 2$ case with various swarm sizes and iteration numbers. 
Results from this benchmarking can be seen in (\ref{tab:MATLAB-speedup}, \ref{tab:ST-speedup}, \ref{tab:OpenMP-speedup}). Unless otherwise 
specified, all data within this thesis was computed as the average of 30 algorithm executions held constant at the given parameters. 
Numerical analysis was additionally performed on the $\beta=4,6,8 \text{ and } 10$ cases, though these solutions were not benchmarked for execution time.

\section{MATLAB}

\subsection{Integrator}

\noindent MATLAB implements a fifth order Runge-Kutta Dormand Prince variable step sized integrator with the native \code{ODE45} function. \code{ODE45}
defaults to a minimum step size of $h_{min}$ as given in Eq. (\ref{eq:min-step-size}). Additionally, \code{ODE45}
presents configuration options for both $AbsTol$ and $RelTol$, utilizing the larger (less-strict) of the two values. 
Integrations for both thrust arcs were configured utilizing the values given in Eq. (\ref{eq:tolerances}).

\subsection{Implementation Details}

\noindent As a stochastic algorithm, particle swarm optimization requires uniformly distributed random numbers to update particle velocities 
and explore the search space. MATLAB provides a \code{rand} function to generate uniformly distributed
psuedo-random numbers. These numbers were then used to compute velocity accelerator coefficients as given by Eq. (\ref{eq:acceleratorCoefficients}).
Solutions were computed using the default 16 digits of precision. Execution time was measured using the standard MATLAB
function \code{tic} and \code{toc}.


\subsection{Thrust Arcs}

\noindent Further analysis of optimal thrust arcs throughout the duration of the orbital transfer was computed within MATLAB.
The transfer was broken down into its three distinct components: the first thrust arc, the coasting arc, and the second thrust arc. 
A set of $r$ and $\theta$ values throughout these three durations were joined together and used to create a polar plot of the given particle's transfer
solution. Results of these computations can be seen in (\ref{fig:Tarc-B2}). \newline

\subsection{Thrust Angles}

\noindent Analysis of the finite thrust transfer problem yields optimal thrust-pointing-angle time history for a given transfer. 
Utilizing Eq. (\ref{delta_eq}) the thrust angle $\delta$ is computed for both the first and second thrust arcs. MATLAB is then used
to graphically model the thrust angle as a function of various quasi-optimal solutions. These results are seen in 
(\ref{fig:thrustAnglesB2}). \newline

\subsection{Rehyrdration}

\noindent \textit{Rehydration} is this thesis' term for the resetting of a percentage of the particle swarm under population stagnation.
This method seeks to expand the search space explored throughout the duration of the algorithm in pursuit of an optimal solution. Certain
stagnation criteria are defined to aid in stagnation determination. To quantify population diversity, the algorithm measures the average
percentage change of $J$, deemed $\delta_J$, 

\section{C++ Single Threaded}
\noindent Details about Boost libraries, timers, etc. go here
\section{C++ Parallelization}
\noindent Details about OpenMP

\newpage